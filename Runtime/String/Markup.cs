using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Burst;
using Unity.Collections.LowLevel.Unsafe;

namespace Elfenlabs.String // Assuming your namespace
{
    [Flags]
    public enum MarkupRuleFlag
    {
        None = 0,
        AllowElementValue = 1 << 0,       // Allows <tag=value> syntax
        AllowValuelessAttribute = 1 << 1, // Allows <tag attribute> syntax
        AllowEmptyTag = 1 << 2,           // Allows <tag/> syntax (self-closing)
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Range : IEquatable<Range>
    {
        public int Start;
        public int Length;
        public bool IsEmpty => Length <= 0;

        public Range(int start, int length)
        {
            Start = start;
            Length = length;
        }

        public bool Equals(Range other) => Start == other.Start && Length == other.Length;
        public override int GetHashCode() => Start.GetHashCode() ^ (Length.GetHashCode() << 2);
        public override string ToString() => IsEmpty ? "Empty" : $"[{Start}..{Start + Length - 1}] ({Length})";
        public static readonly Range Empty = new Range(-1, 0);

        // Helper to get string from original char* (Not for direct use in Burst exception messages)
        internal unsafe string GetString(char* basePtr)
        {
            if (IsEmpty || basePtr == null) return string.Empty;
            return new string(basePtr, Start, Length);
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Element : IEquatable<Element>
    {
        public Range Content;
        public Range TagName;
        public Range FullOpeningTag;
        public Range Value; // For <tag=value>

        public bool Equals(Element other) => Content.Equals(other.Content) && TagName.Equals(other.TagName) && FullOpeningTag.Equals(other.FullOpeningTag) && Value.Equals(other.Value);
        public override int GetHashCode() => Content.GetHashCode() ^ (TagName.GetHashCode() << 2) ^ (FullOpeningTag.GetHashCode() << 4) ^ (Value.GetHashCode() << 6);
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct ElementAttribute : IEquatable<ElementAttribute>
    {
        public int ElementIndex;
        public Range Key;
        public Range Value;

        public bool Equals(ElementAttribute other) => ElementIndex == other.ElementIndex && Key.Equals(other.Key) && Value.Equals(other.Value);
        public override int GetHashCode() => ElementIndex.GetHashCode() ^ (Key.GetHashCode() << 2) ^ (Value.GetHashCode() << 4);
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct OpenElementInfo : IEquatable<OpenElementInfo>
    {
        public int ElementListIndex;
        public Range TagName;
        public int ContentStartIndex;

        public bool Equals(OpenElementInfo other) =>
            ElementListIndex == other.ElementListIndex &&
            TagName.Equals(other.TagName) &&
            ContentStartIndex == other.ContentStartIndex;
        public override int GetHashCode() => ElementListIndex.GetHashCode() ^ (TagName.GetHashCode() << 2) ^ (ContentStartIndex.GetHashCode() << 4);
    }

    // --- Custom Burst-Friendly Exception Types ---
    public class MarkupParseException : ArgumentException
    {
        public Range ErrorRange { get; }
        public Range ContextRange { get; } // Optional: e.g., the tag name for an attribute error

        public MarkupParseException(string message, Range errorRange, Range contextRange = default) : base(message)
        {
            ErrorRange = errorRange;
            ContextRange = contextRange;
        }
        // Constructor for Burst (cannot take string message directly if thrown from Burst)
        public MarkupParseException(Range errorRange, Range contextRange = default)
            : base() // Base constructor, message will be generated by caller
        {
            ErrorRange = errorRange;
            ContextRange = contextRange;
        }
    }

    public class ValuelessAttributeNotAllowedException : MarkupParseException
    {
        public Range AttributeNameRange { get; }
        public Range TagNameRange { get; }
        public ValuelessAttributeNotAllowedException(Range attributeNameRange, Range tagNameRange)
            : base(attributeNameRange, tagNameRange) { AttributeNameRange = attributeNameRange; TagNameRange = tagNameRange; }
    }
    public class ElementValueNotAllowedException : MarkupParseException
    {
        public Range TagNameRange { get; }
        public ElementValueNotAllowedException(Range tagNameRange, Range elementValueOperatorRange)
            : base(elementValueOperatorRange, tagNameRange) { TagNameRange = tagNameRange; }
    }
    // Add other specific exception types as needed (e.g., UnterminatedTagException, MismatchedTagException)


    public static unsafe class MarkupParser
    {
        // Wrapper for managed string input
        public static void ParseMarkup(
            string str,
            Allocator allocator,
            out NativeList<Element> elements,
            out NativeList<ElementAttribute> attributes,
            MarkupRuleFlag rules = MarkupRuleFlag.AllowValuelessAttribute | MarkupRuleFlag.AllowEmptyTag)
        {
            if (string.IsNullOrEmpty(str))
            {
                elements = new NativeList<Element>(0, allocator);
                attributes = new NativeList<ElementAttribute>(0, allocator);
                return;
            }

            fixed (char* charPtr = str)
            {
                try
                {
                    ParseMarkupInternal(charPtr, str.Length, allocator, out elements, out attributes, rules);
                }
                catch (ValuelessAttributeNotAllowedException e)
                {
                    // Format the detailed error message here using the original string
                    string tagName = e.TagNameRange.IsEmpty ? "UNKNOWN_TAG" : e.TagNameRange.GetString(charPtr);
                    string attrName = e.AttributeNameRange.GetString(charPtr);
                    throw new ArgumentException($"Valueless attribute '{attrName}' not allowed for tag '{tagName}' at index {e.AttributeNameRange.Start}. Rule 'AllowValuelessAttribute' is not set.", e);
                }
                catch (ElementValueNotAllowedException e)
                {
                    string tagName = e.TagNameRange.GetString(charPtr);
                    throw new ArgumentException($"Element value syntax not allowed for tag '{tagName}' at index {e.ErrorRange.Start}. Rule 'AllowElementValue' is not set.", e);
                }
                catch (MarkupParseException e) // Catch other generic markup parse exceptions
                {
                    // Potentially format a more generic message if needed, or rethrow
                    // This example assumes the message in MarkupParseException was for Burst (i.e., empty)
                    throw new ArgumentException($"Markup parsing error near index {e.ErrorRange.Start} (length {e.ErrorRange.Length}). Context: {e.ContextRange.GetString(charPtr)}", e);
                }
                catch (ArgumentException e) // Catch exceptions thrown by Burst version if they already have messages
                {
                    // Re-throw if it's already an ArgumentException with a message
                    // Or wrap it if you want to add more context
                    throw;
                }
                // Add catches for other custom exceptions
            }
        }

        // Renamed to ParseMarkupInternal for clarity, this is the Burst-targetable part
        [BurstCompile]
        public static void ParseMarkupInternal(
            char* charPtr,
            int charLength,
            Allocator allocator,
            out NativeList<Element> elements,
            out NativeList<ElementAttribute> attributes,
            MarkupRuleFlag rules = MarkupRuleFlag.AllowValuelessAttribute | MarkupRuleFlag.AllowEmptyTag)
        {
            elements = new NativeList<Element>(16, allocator);
            attributes = new NativeList<ElementAttribute>(32, allocator);

            if (charPtr == null || charLength == 0)
            {
                return;
            }

            var openElementStack = new NativeList<OpenElementInfo>(8, Allocator.Temp);

            try
            {
                int i = 0;
                while (i < charLength)
                {
                    if (charPtr[i] == '<')
                    {
                        int tagStartIndex = i;
                        i++;

                        if (i >= charLength) throw new MarkupParseException(new Range(tagStartIndex, 1)); // Unterminated tag

                        if (charPtr[i] == '/') // Closing Tag
                        {
                            i++;
                            int closingTagNameStart = i;
                            while (i < charLength && charPtr[i] != '>') i++;
                            if (i >= charLength) throw new MarkupParseException(new Range(closingTagNameStart - 2, charLength - (closingTagNameStart - 2))); // Unterminated

                            Range closingTagName = new Range(closingTagNameStart, i - closingTagNameStart);
                            i++;

                            if (openElementStack.Length > 0)
                            {
                                OpenElementInfo lastOpenElement = openElementStack[openElementStack.Length - 1];
                                if (CompareRanges(charPtr, lastOpenElement.TagName, charPtr, closingTagName) == 0)
                                {
                                    Element elementToUpdate = elements[lastOpenElement.ElementListIndex];
                                    elementToUpdate.Content = new Range(lastOpenElement.ContentStartIndex, tagStartIndex - lastOpenElement.ContentStartIndex);
                                    elements[lastOpenElement.ElementListIndex] = elementToUpdate;
                                    openElementStack.RemoveAt(openElementStack.Length - 1);
                                }
                                // else { /* Mismatched closing tag - throw MismatchedTagException(lastOpenElement.TagName, closingTagName) */ }
                            }
                            // else { /* Unexpected closing tag - throw UnexpectedClosingTagException(closingTagName) */ }
                            continue;
                        }

                        // Opening Tag
                        int openingTagNameStart = i;
                        while (i < charLength && !IsWhiteSpaceOrTagChar(charPtr[i]) && charPtr[i] != '=') i++;
                        if (i >= charLength) throw new MarkupParseException(new Range(tagStartIndex, charLength - tagStartIndex)); // Unterminated

                        Range tagName = new Range(openingTagNameStart, i - openingTagNameStart);
                        if (tagName.IsEmpty) throw new MarkupParseException(new Range(openingTagNameStart, 0)); // Empty tag name

                        int currentElementIndex = elements.Length;
                        Element newElement = new Element { TagName = tagName, FullOpeningTag = new Range(tagStartIndex, 0), Content = Range.Empty, Value = Range.Empty };
                        elements.Add(newElement);

                        bool elementValueSet = false;
                        while (i < charLength && charPtr[i] != '>' && !(charPtr[i] == '/' && i + 1 < charLength && charPtr[i + 1] == '>'))
                        {
                            while (i < charLength && char.IsWhiteSpace(charPtr[i])) i++;
                            if (i >= charLength || charPtr[i] == '>' || (charPtr[i] == '/' && i + 1 < charLength && charPtr[i + 1] == '>')) break;

                            bool isPotentialElementValue = charPtr[i] == '=' && elements[currentElementIndex].TagName.Start == openingTagNameStart && attributes.Length == 0; // Simplified check

                            if (isPotentialElementValue)
                            {
                                if (!rules.HasFlag(MarkupRuleFlag.AllowElementValue))
                                {
                                    throw new ElementValueNotAllowedException(tagName, new Range(i, 1));
                                }
                                if (elementValueSet) throw new MarkupParseException(new Range(i, 1), tagName); // Multiple element values

                                i++;
                                int elementValueStart = i; char quoteChar = '\0';
                                if (i < charLength && (charPtr[i] == '"' || charPtr[i] == '\'')) { quoteChar = charPtr[i]; i++; elementValueStart = i; }
                                while (i < charLength)
                                {
                                    if (quoteChar != '\0' && charPtr[i] == quoteChar) break;
                                    if (quoteChar == '\0' && (IsWhiteSpaceOrTagChar(charPtr[i]))) break;
                                    i++;
                                }
                                Range elementValueRange = new Range(elementValueStart, i - elementValueStart);
                                Element tempElem = elements[currentElementIndex]; tempElem.Value = elementValueRange; elements[currentElementIndex] = tempElem;
                                elementValueSet = true;
                                if (quoteChar != '\0' && i < charLength && charPtr[i] == quoteChar) i++;
                                continue;
                            }

                            int attrNameStart = i;
                            while (i < charLength && !IsWhiteSpaceOrTagChar(charPtr[i]) && charPtr[i] != '=') i++;
                            Range attrName = new Range(attrNameStart, i - attrNameStart);
                            if (attrName.IsEmpty) throw new MarkupParseException(new Range(attrNameStart, 0), tagName); // Empty attribute name

                            while (i < charLength && char.IsWhiteSpace(charPtr[i])) i++;

                            Range attrValue = Range.Empty;
                            if (i < charLength && charPtr[i] == '=')
                            {
                                i++; while (i < charLength && char.IsWhiteSpace(charPtr[i])) i++;
                                if (i >= charLength) throw new MarkupParseException(attrName, tagName); // Unterminated attribute

                                int attrValueStart = i; char quoteChar = '\0';
                                if (charPtr[i] == '"' || charPtr[i] == '\'') { quoteChar = charPtr[i]; i++; attrValueStart = i; }
                                while (i < charLength)
                                {
                                    if (quoteChar != '\0' && charPtr[i] == quoteChar) break;
                                    if (quoteChar == '\0' && (IsWhiteSpaceOrTagChar(charPtr[i]))) break;
                                    i++;
                                }
                                attrValue = new Range(attrValueStart, i - attrValueStart);
                                if (quoteChar != '\0' && i < charLength && charPtr[i] == quoteChar) i++;
                            }
                            else if (!rules.HasFlag(MarkupRuleFlag.AllowValuelessAttribute))
                            {
                                throw new ValuelessAttributeNotAllowedException(attrName, tagName);
                            }
                            attributes.Add(new ElementAttribute { ElementIndex = currentElementIndex, Key = attrName, Value = attrValue });
                        }

                        bool selfClosing = false;
                        if (i < charLength && charPtr[i] == '/')
                        {
                            i++;
                            if (i < charLength && charPtr[i] == '>')
                            {
                                if (!rules.HasFlag(MarkupRuleFlag.AllowEmptyTag)) throw new MarkupParseException(new Range(tagStartIndex, i - tagStartIndex + 1), tagName); // Self-closing not allowed
                                selfClosing = true;
                            }
                            else throw new MarkupParseException(new Range(tagStartIndex, i - tagStartIndex), tagName); // Malformed self-closing
                        }

                        if (i < charLength && charPtr[i] == '>')
                        {
                            i++;
                            Element currentElem = elements[currentElementIndex];
                            currentElem.FullOpeningTag = new Range(tagStartIndex, i - tagStartIndex);
                            if (selfClosing) currentElem.Content = Range.Empty;
                            else
                            {
                                currentElem.Content = new Range(i, 0);
                                openElementStack.Add(new OpenElementInfo { ElementListIndex = currentElementIndex, TagName = tagName, ContentStartIndex = i });
                            }
                            elements[currentElementIndex] = currentElem;
                        }
                        else throw new MarkupParseException(new Range(tagStartIndex, charLength - tagStartIndex), tagName); // Unterminated opening tag
                    }
                    else
                    {
                        i++; // Regular character
                    }
                }

                // Handle unclosed tags
                for (int k = 0; k < openElementStack.Length; ++k)
                {
                    OpenElementInfo openElement = openElementStack[k];
                    Element elementToUpdate = elements[openElement.ElementListIndex];
                    if (elementToUpdate.Content.Start == openElement.ContentStartIndex && elementToUpdate.Content.Length == 0)
                    {
                        // Consider this a parsing error for stricter parsing
                        // throw new MarkupParseException(elementToUpdate.TagName, elementToUpdate.FullOpeningTag); // Unclosed tag
                        if (openElement.ContentStartIndex < charLength)
                        {
                            elementToUpdate.Content = new Range(openElement.ContentStartIndex, charLength - openElement.ContentStartIndex);
                            elements[openElement.ElementListIndex] = elementToUpdate;
                        }
                    }
                }
            }
            finally
            {
                if (openElementStack.IsCreated) openElementStack.Dispose();
            }
        }

        private static int CompareRanges(char* ptr1, Range range1, char* ptr2, Range range2)
        {
            if (range1.Length != range2.Length) return range1.Length - range2.Length;
            if (range1.IsEmpty) return 0;
            return UnsafeUtility.MemCmp(ptr1 + range1.Start, ptr2 + range2.Start, (long)range1.Length * sizeof(char));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsWhiteSpaceOrTagChar(char c)
        {
            return char.IsWhiteSpace(c) || c == '>' || c == '/';
        }
    }
}